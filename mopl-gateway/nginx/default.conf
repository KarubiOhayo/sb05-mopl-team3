server {
    # 80 포트로 들어오는 HTTP 요청을 받는다.
    listen 80;
    # 도메인이 정해져 있지 않은 로컬/개발환경에서 모든 호스트를 받는 설정
    server_name _;

    # 1) Frontend (SPA) (정적 파일 서빙)
    # Nginx가 정적 파일을 찾을 웹 루트 경로
    # docker-compose에서 이 경로에 프론트 빌드(dist/build)를 마운트 - 저는 build 안에 코드잇에서 제공받은 dist 폴더를 넣었습니다.
    root /usr/share/nginx/html;
    # 기본으로 열어줄 파일
    index index.html;

    location / {
        # SPA(React, vue) 라우팅 지원을 위한 설정
        # 요청한 경로에 해당 파일이 실제로 존재하면($uri) 그 파일을 주고,
        # 없으면(index.html)로 돌려서 프론트 라우터가 처리하게 한다.
        # 예시 : /profile 같은 URL로 새로고침해도 404가 아니라 index.html을 내려줌
        try_files $uri $uri/ /index.html;
    }

    # 2) REST API 프록시 (/api -> mopl-api:8080)
    location /api/ {
         # /api 로 들어온 요청을 백엔드 API 서버로 전달한다.
        # 여기서는 IntelliJ로 실행 중인 mopl-api(8080)로 보냄
        # (같은 도커 네트워크에 api 컨테이너가 있으면 api:8080 같은 서비스명 사용)

        # 로컬
        proxy_pass http://host.docker.internal:8080;

        #운영
#         ECS 서비스 디스커버리(Cloud Map)
#         proxy_pass http://mopl-api:8080
#         같은 task(sidecar)
#         proxy_pass http://127.0.0.1:8080
#         내부 ALB를 쓰면
#         proxy_pass http://<internal-alb-dns>

        # HTTP/1.1을 사용(keep-alive 및 일부 연결 유지에 유리)
        proxy_http_version 1.1;
        # 원본 요청 정보를 백엔드로 전달하기 위한 표준 헤더들
        proxy_set_header Host $host; # 원래 Host 유지
        proxy_set_header X-Real-IP $remote_addr;  # 클라이언트 IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 프록시 체인 IP
        proxy_set_header X-Forwarded-Proto $scheme; # http/https 정보
    }

    # 3) SSE 프록시 (/api/sse -> mopl-api)
    location /api/sse {
        # SSE 엔드포인트로 프록시

        # 로컬
        proxy_pass http://host.docker.internal:8080/api/sse;

        # 운영
#         ECS 서비스 디스커버리(Cloud Map)
          # proxy_pass http://mopl-api:8080/api/sse
#         같은 task(sidecar)
          # proxy_pass http://127.0.0.1:8080/api/sse
#         내부 ALB를 쓰면
          # proxy_pass http://<internal-alb-dns>/api/sse

        proxy_http_version 1.1;

        # SSE는 "계속 연결을 유지하며" 데이터를 흘려보내는 형태라
        # 불필요한 Connection 헤더 처리를 조심해야 함.
        proxy_set_header Connection "";

        # SSE는 버퍼링되면 실시간성이 깨진다.
        # 데이터를 모아서 한 번에 보내지 말고, 바로바로 흘려보내도록 설정
        proxy_buffering off;
        proxy_cache off;

        # SSE 연결은 오래 지속되므로 타임아웃을 길게 잡는다.
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    # 4) WebSocket 프록시 (/ws -> mopl-socket)
    location /ws {
        # /ws로 들어오는 요청을 socket 서버(8081)로 전달한다.
        # WebSocket은 HTTP에서 시작해서 "업그레이드" 되므로 헤더가 중요

        # 로컬
        proxy_pass http://host.docker.internal:8081/ws;

        # 운영
        # proxy_pass http://mopl-socket:8081/ws
        # proxy_pass http://127.0.0.1:8081/ws
        # proxy_pass http://<internal-alb-dns>/ws

        proxy_http_version 1.1;

        # WebSocket 업그레이드에 필요한 헤더 세트
        proxy_set_header Upgrade $http_upgrade;       # Upgrade: websocket
        proxy_set_header Connection "upgrade";        # Connection: upgrade
        proxy_set_header Host $host;

        # WebSocket도 연결이 오래 유지되므로 타임아웃을 길게
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }
}
